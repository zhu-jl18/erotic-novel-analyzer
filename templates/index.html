<!DOCTYPE html>
<html lang="zh-CN" x-data="app()" :data-theme="theme">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>涩涩小说分析器</title>
    <link rel="icon" type="image/svg+xml" href="https://www.svgrepo.com/show/529409/book.svg" />
    <link
      href="https://cdn.jsdelivr.net/npm/daisyui@4/dist/full.min.css"
      rel="stylesheet"
    />
    <script src="https://cdn.tailwindcss.com"></script>
    <script
      defer
      src="https://cdn.jsdelivr.net/npm/alpinejs@3/dist/cdn.min.js"
    ></script>
    <link rel="stylesheet" href="/static/style.css?v=22&t=1736168800" />
    <script src="https://unpkg.com/lucide@latest"></script>
  </head>
  <body class="min-h-screen bg-base-100 antialiased">
    <!-- 顶栏 - 极简精致 -->
    <div
      class="navbar sticky top-0 z-40 bg-base-100/90 backdrop-blur-xl border-b border-[var(--glass-border)]"
    >
      <div class="max-w-4xl mx-auto px-6 py-4 w-full flex items-center">
        <div class="flex-1">
          <span class="text-lg font-semibold bg-gradient-to-r from-pink-500 via-purple-500 to-indigo-500 bg-clip-text text-transparent" style="letter-spacing: -0.01em;">涩涩小说分析器</span>
        </div>
        <div class="flex-none gap-1">
          <button
            class="p-2.5 rounded-full hover:bg-[var(--glass-hover)] transition-all duration-200"
            @click="settingsOpen = true"
            title="配置"
          >
            <svg
              xmlns="http://www.w3.org/2000/svg"
              class="w-[1.15rem] h-[1.15rem] opacity-55"
              fill="none"
              viewBox="0 0 24 24"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            >
              <circle cx="12" cy="12" r="3"></circle>
              <path
                d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06-.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1 1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51-1z"
              ></path>
            </svg>
          </button>
          <button
            class="p-2.5 rounded-full hover:bg-[var(--glass-hover)] transition-all duration-200"
            @click="toggleTheme()"
            title="切换主题"
          >
            <svg
              x-show="theme === 'dark'"
              xmlns="http://www.w3.org/2000/svg"
              class="w-5 h-5 opacity-60"
              fill="none"
              viewBox="0 0 24 24"
              stroke="currentColor"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="1.5"
                d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"
              />
            </svg>
            <svg
              x-show="theme === 'light'"
              xmlns="http://www.w3.org/2000/svg"
              class="w-5 h-5 opacity-60"
              fill="none"
              viewBox="0 0 24 24"
              stroke="currentColor"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="1.5"
                d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"
              />
            </svg>
          </button>
        </div>
      </div>
    </div>

    <!-- 主内容 -->
    <main class="min-h-[calc(100vh-80px)]">
      <div class="max-w-4xl mx-auto px-6 py-12">
        <!-- 主内容区域 -->
        <div class="animate-in">
          <!-- 顶部：小说名 + 操作 -->
          <div class="flex items-center justify-between mb-8">
            <div class="dropdown dropdown-bottom">
              <div
                tabindex="0"
                role="button"
                data-testid="novel-dropdown"
                class="float-input flex items-center gap-3 cursor-pointer"
              >
                <span
                  x-text="selectedNovel ? selectedNovel.name : '选择小说...'"
                  >选择小说...</span
                >
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  class="w-4 h-4 opacity-40"
                  fill="none"
                  viewBox="0 0 24 24"
                  stroke="currentColor"
                >
                  <path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M19 9l-7 7-7-7"
                  />
                </svg>
              </div>
              <div
                tabindex="0"
                class="dropdown-content z-50 bg-base-200 rounded-xl shadow-2xl w-72 max-h-80 overflow-y-auto mt-2"
              >
                <div class="p-3 text-xs opacity-50" x-text="fileStats">
                  加载中...
                </div>
                <div id="folderList2" class="p-2 space-y-1"></div>
              </div>
            </div>
            <div class="flex items-center gap-2">
              <button
                class="px-4 py-2 rounded-full bg-[#7c3aed] text-white text-sm font-medium transition-all hover:bg-[#6d28d9] flex items-center gap-2"
                data-testid="analyze-button"
                @click="analyzeNovel()"
                :disabled="!selectedNovel || loading"
              >
                <span
                  class="loading loading-spinner loading-xs"
                  x-show="loading"
                ></span>
                <i data-lucide="refresh-cw" class="w-4 h-4" x-show="!loading && hasAnyResult()"></i>
                <span
                  x-text="loading ? '分析中' : (hasAnyResult() ? '重新分析' : '开始分析')"
                ></span>
              </button>
              <button
                class="px-4 py-2 rounded-full text-sm font-medium transition-colors hover:bg-[var(--glass)] disabled:opacity-40 disabled:cursor-not-allowed flex items-center gap-2"
                @click="doExport()"
                :disabled="!analysisComplete || loading"
              >
                <i data-lucide="download" class="w-4 h-4"></i>
                导出
              </button>
            </div>
          </div>

          <!-- Pill Tabs -->
          <div class="pill-tabs mb-8">
            <template x-for="tab in tabs" :key="tab.id">
              <button
                class="pill-tab"
                :class="{ 'active': currentTab === tab.id, 'opacity-40 cursor-not-allowed': !isTabEnabled(tab) }"
                :disabled="!isTabEnabled(tab)"
                @click="isTabEnabled(tab) && (currentTab = tab.id)"
              >
                <span x-text="tab.name"></span>
              </button>
            </template>
          </div>

          <!-- Tab内容 -->
          <div class="animate-in">
            <div class="glass-card p-6 mb-8" x-show="currentTab === 'pipeline' && !hasAnyResult()" x-cloak>
              <div class="text-sm opacity-60">已选择小说</div>
              <div
                class="text-lg font-semibold mt-1"
                x-text="selectedNovel ? selectedNovel.name : '未选择'"
              ></div>
              <div
                class="text-sm opacity-60 mt-2"
                x-show="currentNovelLength"
                x-text="'字数：' + formatWordCount(currentNovelLength) + '字'"
              ></div>
              <div class="text-xs opacity-50 mt-2">
                点击右上角“开始分析”生成新结果（旧结果已清空）
              </div>
            </div>
            <!-- 进度 -->
            <div x-show="currentTab === 'pipeline'" x-cloak>
              <div class="glass-card p-6 mb-8">
                <div class="card-header mb-4">
                  <i data-lucide="activity" class="card-icon"></i>
                  <span class="card-title">分析进度</span>
                </div>
                <div class="progress-list">
                  <template x-for="step in progressSteps" :key="step.id">
                    <div class="progress-item" :class="'status-' + step.status">
                      <div
                        class="progress-icon"
                        :class="{ 'spin': step.status === 'running' }"
                      >
                        <i :data-lucide="statusIcon(step.status)"></i>
                      </div>
                      <div class="progress-content">
                        <div class="progress-name" x-text="step.label"></div>
                        <div class="progress-detail" x-text="step.detail"></div>
                      </div>
                      <div class="progress-status" x-text="statusLabel(step.status)"></div>
                      <button
                        class="ml-2 px-3 py-1 rounded-full text-xs font-medium border border-base-300 hover:bg-[var(--glass)] transition disabled:opacity-40 disabled:cursor-not-allowed"
                        x-show="isStepActionVisible(step.id)"
                        :disabled="!canRunStep(step.id) || step.status === 'running'"
                        @click="runSingleStep(step.id)"
                      >
                        <span x-text="stepActionLabel(step)"></span>
                      </button>
                    </div>
                  </template>
                </div>
              </div>
            </div>
            <!-- 总结 -->
            <div x-show="currentTab === 'summary'" x-cloak>
              <div id="quickStats"></div>
              <div id="relationshipSummary"></div>
            </div>
            <!-- 雷点 -->
            <div x-show="currentTab === 'thunderzones'" x-cloak>
              <div id="thunderzoneSection"></div>
            </div>
            <!-- 涩情元素 -->
            <div x-show="currentTab === 'lewd-elements'" x-cloak>
              <div id="lewdElementsSection"></div>
            </div>
            <!-- 主角 -->
            <div x-show="currentTab === 'characters'" x-cloak>
              <div id="mainCharacters"></div>
            </div>
            <!-- 关系图 -->
            <div x-show="currentTab === 'relationships'" x-cloak>
              <div class="h-[600px]" id="relationshipChart"></div>
              <div class="mt-6" id="relationshipDetails"></div>
            </div>
            <!-- 首次 -->
            <div x-show="currentTab === 'firstsex'" x-cloak>
              <div id="firstSexScene"></div>
            </div>
            <!-- 统计 -->
            <div x-show="currentTab === 'count'" x-cloak>
              <div id="sexSceneCount"></div>
            </div>
            <!-- 发展 -->
            <div x-show="currentTab === 'progress'" x-cloak>
              <div id="relationshipProgress"></div>
            </div>
            <!-- 日志 -->
            <div x-show="currentTab === 'logs'" x-cloak>
              <div class="flex justify-between items-center mb-4">
                <span
                  class="text-sm opacity-60"
                  x-text="logs.length + ' 条日志'"
                ></span>
                <button
                  class="text-sm opacity-60 hover:opacity-100 transition-opacity"
                  @click="clearLog()"
                >
                  清空
                </button>
              </div>
              <div
                class="log-container space-y-2 font-mono text-xs max-h-[600px] overflow-y-auto"
              >
                <template x-for="(entry, idx) in logs" :key="idx">
                  <div
                    class="log-entry p-3 rounded-lg"
                    :class="'log-' + entry.level"
                  >
                    <div class="flex items-center gap-2 mb-1">
                      <span
                        class="log-level-badge"
                        :class="'log-level-' + entry.level"
                        x-text="entry.level.toUpperCase()"
                      ></span>
                      <span class="opacity-40" x-text="entry.time"></span>
                    </div>
                    <div class="log-message" x-text="entry.message"></div>
                    <pre
                      x-show="entry.data"
                      class="mt-2 text-xs opacity-60 whitespace-pre-wrap overflow-x-auto"
                      x-text="entry.data"
                    ></pre>
                  </div>
                </template>
                <div
                  x-show="logs.length === 0"
                  class="text-center py-8 opacity-40"
                >
                  暂无日志
                </div>
              </div>
            </div>
            <!-- 调试 -->
            <div x-show="currentTab === 'debug'" x-cloak>
              <div class="glass-card p-6 mb-6">
                <div class="card-header mb-3">
                  <i data-lucide="bug" class="card-icon"></i>
                  <span class="card-title">LLM 原始调用（落盘）</span>
                </div>
                <p class="text-sm opacity-60 leading-relaxed">
                  用于排查“返回未知 / 雷点为空 / Function Call不规范”等问题。建议在
                  <code class="px-1 py-0.5 rounded bg-[var(--glass)]">.env</code>
                  中设置
                  <code class="px-1 py-0.5 rounded bg-[var(--glass)]">LLM_DUMP_ENABLED=true</code>
                  （或
                  <code class="px-1 py-0.5 rounded bg-[var(--glass)]">DEBUG=true</code>）
                  后重启服务端。
                </p>
                <div class="mt-4 flex flex-wrap gap-2">
                  <button
                    class="rounded-full px-4 py-2 text-sm font-medium hover:bg-[var(--glass)] transition"
                    @click="loadLlmDumps()"
                    :disabled="llmDumpsLoading"
                  >
                    <span
                      class="loading loading-spinner loading-xs"
                      x-show="llmDumpsLoading"
                    ></span>
                    刷新列表
                  </button>
                  <button
                    class="rounded-full px-4 py-2 text-sm font-medium text-error hover:bg-error/10 transition"
                    @click="clearLlmDumps()"
                    :disabled="llmDumpsLoading"
                  >
                    清空 dumps
                  </button>
                  <span class="text-xs opacity-60 flex items-center">
                    <span class="mr-2">enabled:</span>
                    <span class="font-mono" x-text="serverConfig.llm_dump_enabled ? 'true' : 'false'"></span>
                    <span class="mx-2">dir:</span>
                    <span class="font-mono break-all" x-text="serverConfig.llm_dump_dir || '-'"></span>
                  </span>
                </div>
              </div>

              <div class="glass-card p-6 mb-6">
                <div class="flex items-center justify-between mb-3">
                  <div class="card-header !mb-0">
                    <i data-lucide="file-json" class="card-icon"></i>
                    <span class="card-title">当前分析结果（合并）</span>
                  </div>
                  <button
                    class="rounded-full px-4 py-2 text-sm font-medium hover:bg-[var(--glass)] transition"
                    @click="copyText(analysisJson())"
                  >
                    复制 JSON
                  </button>
                </div>
                <pre
                  class="text-xs font-mono whitespace-pre-wrap break-words max-h-[360px] overflow-y-auto opacity-80"
                  x-text="analysisJson() || '暂无分析结果'"
                ></pre>
              </div>

              <div class="grid gap-4 md:grid-cols-2">
                <div class="glass-card p-4">
                  <div class="flex items-center justify-between mb-3">
                    <span class="text-sm font-semibold">dump 列表</span>
                    <span class="text-xs opacity-60" x-text="llmDumps.length + ' 条'"></span>
                  </div>
                  <div class="space-y-2 max-h-[560px] overflow-y-auto">
                    <template x-for="item in llmDumps" :key="item.id">
                      <button
                        class="w-full text-left rounded-xl border border-base-300 bg-base-200/60 px-3 py-2 hover:bg-base-200 transition"
                        @click="loadLlmDump(item.id)"
                      >
                        <div class="text-xs font-mono break-all" x-text="item.id"></div>
                        <div class="mt-1 text-xs opacity-60">
                          <span x-text="item.mtime || ''"></span>
                          <span class="mx-2">·</span>
                          <span x-text="formatBytes(item.size || 0)"></span>
                        </div>
                      </button>
                    </template>
                    <div
                      x-show="llmDumps.length === 0"
                      class="text-center py-10 opacity-40 text-sm"
                    >
                      暂无 dumps（需要启用 LLM_DUMP_ENABLED/DEBUG）
                    </div>
                  </div>
                </div>

                <div class="glass-card p-4">
                  <div class="flex items-center justify-between mb-3">
                    <span class="text-sm font-semibold">dump 详情</span>
                    <span class="text-xs opacity-60 font-mono break-all" x-text="selectedDumpId || ''"></span>
                  </div>
                  <pre
                    class="text-xs font-mono whitespace-pre-wrap break-words max-h-[560px] overflow-y-auto opacity-80"
                    x-text="selectedDumpText || '选择左侧一条 dump 查看'"
                  ></pre>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- 错误提示 -->
        <div
          class="fixed inset-0 z-50 flex items-center justify-center bg-black/40 backdrop-blur-sm"
          x-show="errorMsg"
          x-cloak
          x-transition
        >
          <div class="w-[min(92vw,760px)] rounded-2xl border border-base-300 bg-base-100 p-6 shadow-2xl">
            <div class="flex items-start gap-4">
              <div class="flex h-12 w-12 items-center justify-center rounded-full bg-error/15 text-2xl text-error">
                ⚠️
              </div>
              <div class="flex-1">
                <div class="text-lg font-semibold">分析失败</div>
                <div class="mt-1 text-sm opacity-70">
                  请求被拒绝或内容过长，请检查输入或查看日志
                </div>
              </div>
              <button
                class="rounded-full px-3 py-1 text-sm opacity-60 hover:bg-[var(--glass)] hover:opacity-100 transition"
                @click="errorMsg = ''"
              >
                关闭
              </button>
            </div>
            <div class="mt-4 max-h-[50vh] overflow-y-auto rounded-xl border border-base-300 bg-base-200/60 p-4 text-sm font-mono whitespace-pre-wrap break-words">
              <span x-text="errorMsg"></span>
            </div>
            <div class="mt-4 flex justify-end gap-2">
              <button
                class="rounded-full px-4 py-2 text-sm font-medium hover:bg-[var(--glass)] transition"
                @click="currentTab = 'logs'; errorMsg = ''"
              >
                查看日志
              </button>
              <button
                class="rounded-full bg-error px-4 py-2 text-sm font-medium text-error-content hover:brightness-110 transition"
                @click="errorMsg = ''"
              >
                关闭
              </button>
            </div>
          </div>
        </div>
      </div>
    </main>

    <!-- 设置模态框 -->
    <dialog class="modal" :class="{ 'modal-open': settingsOpen }">
      <div class="modal-box bg-base-100 border-none rounded-2xl max-w-md">
        <h3 class="font-semibold text-lg mb-4">配置</h3>
        <button
          class="absolute right-4 top-4 p-1 rounded-full hover:bg-[var(--glass)] transition-colors opacity-60"
          @click="settingsOpen = false"
        >
          <svg
            xmlns="http://www.w3.org/2000/svg"
            class="w-5 h-5"
            fill="none"
            viewBox="0 0 24 24"
            stroke="currentColor"
          >
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M6 18L18 6M6 6l12 12"
            />
          </svg>
        </button>

        <div class="glass-card p-4 mb-4">
          <p class="text-sm opacity-60">
            配置从服务端
            <code class="px-1 py-0.5 rounded bg-[var(--glass)]">.env</code> 读取
          </p>
        </div>

         <div class="space-y-3 text-sm">
           <div class="flex items-center justify-between gap-3">
             <span class="opacity-50">API URL</span>
             <span
               class="font-mono text-xs truncate max-w-[200px]"
               x-text="serverConfig.api_url || '-'"
             ></span>
           </div>
           <div class="flex items-center justify-between gap-3">
             <span class="opacity-50">MODEL</span>
             <span
               class="font-mono text-xs truncate max-w-[200px]"
               x-text="serverConfig.model || '-'"
             ></span>
           </div>
           <div class="flex items-center justify-between gap-3">
             <span class="opacity-50">Repair</span>
             <span class="font-mono text-xs">
               <span x-text="serverConfig.repair_enabled ? 'enabled' : 'disabled'"></span>
               <span class="opacity-60" x-show="serverConfig.repair_enabled">
                 (<span x-text="serverConfig.repair_max_attempts"></span>)
               </span>
             </span>
           </div>
           <div class="flex items-center justify-between gap-3">
             <span class="opacity-50">LLM Dump</span>
             <span class="font-mono text-xs" x-text="serverConfig.llm_dump_enabled ? 'enabled' : 'disabled'"></span>
           </div>
         </div>

        <div class="flex items-center gap-2 mt-4" x-show="testResult">
          <span
            class="text-sm"
            :class="testResult === 'success' ? 'text-success' : 'text-error'"
            x-text="testResultMsg"
          ></span>
        </div>

        <div class="flex gap-2 mt-6">
          <button
            class="flex-1 py-2.5 rounded-full text-sm font-medium text-error hover:bg-error/10 transition-colors"
            @click="clearAnalysis()"
          >
            清空分析
          </button>
          <button
            class="flex-1 py-2.5 rounded-full text-sm font-medium hover:bg-[var(--glass)] transition-colors"
            @click="testConnection()"
            :disabled="testLoading"
          >
            <span
              class="loading loading-spinner loading-xs"
              x-show="testLoading"
            ></span>
            <span x-text="testLoading ? '' : '测试连接'"></span>
          </button>
        </div>
      </div>
      <form
        method="dialog"
        class="modal-backdrop bg-black/60 backdrop-blur-sm"
        x-show="settingsOpen"
        x-cloak
        @click="settingsOpen = false"
      ></form>
    </dialog>

    <!-- Toast -->
    <div class="toast toast-end" id="toastContainer"></div>

    <script src="/static/chart-view.js?v=3"></script>
    <script>
      function app() {
        return {
          theme: localStorage.getItem("theme") || "dark",
          settingsOpen: false,
          serverConfig: {
            api_url: "",
            model: "",
            repair_enabled: false,
            repair_max_attempts: 0,
            llm_dump_enabled: false,
            llm_dump_dir: "",
          },
          selectedNovel: null,
          currentNovelContent: null,
          currentNovelLength: 0,
          currentAnalysis: null,
          coreRevision: 0,
          sectionRunId: { meta: 0, core: 0, scenes: 0, thunder: 0, lewd: 0 },
          sectionHasResult: {
            meta: false,
            core: false,
            scenes: false,
            thunder: false,
            lewd: false,
          },
          activeRequests: 0,
          loading: false,
          analysisComplete: false,
          errorMsg: "",
          novelTitle: "选择一本小说",
          fileStats: "加载中...",
          currentTab: "pipeline",
          testResult: "",
          testResultMsg: "",
          testLoading: false,
          tabs: [
            { id: "pipeline", name: "进度", alwaysEnabled: true },
            { id: "summary", name: "总结" },
            { id: "thunderzones", name: "雷点" },
            { id: "lewd-elements", name: "涩情元素" },
            { id: "characters", name: "角色" },
            { id: "relationships", name: "关系图" },
            { id: "firstsex", name: "首次" },
            { id: "count", name: "统计" },
            { id: "progress", name: "发展" },
            { id: "logs", name: "日志", alwaysEnabled: true },
            { id: "debug", name: "调试", alwaysEnabled: true },
          ],
          logs: [],
          progressSteps: [],
          llmDumps: [],
          llmDumpsLoading: false,
          selectedDumpId: "",
          selectedDumpText: "",

           init() {
             this.$watch("theme", (val) => localStorage.setItem("theme", val));
             this.$watch("currentTab", (val) => {
               if (val === "relationships" && this.currentAnalysis) {
                 requestAnimationFrame(() => {
                   requestAnimationFrame(() =>
                     renderRelationshipGraph(
                       "relationshipChart",
                       this.currentAnalysis
                     )
                   );
                 });
               }
               if (val === "debug") {
                 this.loadLlmDumps();
               }
             });
            localStorage.removeItem("novel_analyzer_api_url");
            localStorage.removeItem("novel_analyzer_api_key");
            localStorage.removeItem("novel_analyzer_model_name");
            this.loadServerConfig();
            this.scanNovels();
            this.initProgressSteps();
            this.restoreAnalysis();
            this.log("info", "应用初始化完成");
            // Initialize Lucide icons
            if (typeof lucide !== 'undefined') {
              lucide.createIcons();
            }
          },

           async loadServerConfig() {
             try {
               const res = await fetch("/api/config", { cache: "no-store" });
               if (!res.ok) return;
               const data = await res.json();
               this.serverConfig = {
                 api_url: data.api_url || "",
                 model: data.model || "",
                 repair_enabled: !!data.repair_enabled,
                 repair_max_attempts: Number(data.repair_max_attempts ?? 0),
                 llm_dump_enabled: !!data.llm_dump_enabled,
                 llm_dump_dir: data.llm_dump_dir || "",
               };
             } catch {}
           },

          toggleTheme() {
            this.theme = this.theme === "dark" ? "light" : "dark";
          },

           formatWordCount(count) {
             const value = Number(count);
             if (!Number.isFinite(value) || value <= 0) return "0";
             return value > 10000 ? (value / 10000).toFixed(1) + "万" : String(value);
           },

           formatBytes(bytes) {
             const n = Number(bytes);
             if (!Number.isFinite(n) || n <= 0) return "0 B";
             const units = ["B", "KB", "MB", "GB"];
             let v = n;
             let i = 0;
             while (v >= 1024 && i < units.length - 1) {
               v /= 1024;
               i += 1;
             }
             const text = i === 0 ? String(Math.trunc(v)) : v.toFixed(1);
             return `${text} ${units[i]}`;
           },

           detectChapterCount(content) {
             const text = String(content ?? "");
             if (!text) return 0;

             const patterns = [
               /^\s*第\s*([0-9]{1,5}|[一二三四五六七八九十百千两〇零]{1,12})\s*章/gm,
               /^\s*chapter\s+([0-9]{1,5})/gim,
             ];

             for (const re of patterns) {
               const seen = new Set();
               let match;
               while ((match = re.exec(text))) {
                 if (match[1]) seen.add(match[1]);
               }
               if (seen.size > 0) return seen.size;
             }
             return 0;
           },

           blankAnalysis() {
              return {
                novel_info: {},
                summary: "",
                characters: [],
                relationships: [],
                first_sex_scenes: [],
                sex_scenes: { total_count: 0, scenes: [] },
                evolution: [],
                thunderzones: [],
                thunderzone_summary: "",
                lewd_elements: [],
                lewd_elements_summary: "",
              };
            },

           beginRequest() {
             this.activeRequests += 1;
             this.loading = this.activeRequests > 0;
           },

           endRequest() {
             this.activeRequests = Math.max(0, this.activeRequests - 1);
             this.loading = this.activeRequests > 0;
           },

           getStep(id) {
             return this.progressSteps.find((s) => s.id === id) || null;
           },

           getStepStatus(id) {
             return this.getStep(id)?.status || "idle";
           },

           isStepDone(id) {
             return this.getStepStatus(id) === "done";
           },

           hasAnyResult() {
              return ["meta", "core", "scenes", "thunder", "lewd"].some(
                (id) => !!this.sectionHasResult?.[id]
              );
           },

           isAllDone() {
              return ["meta", "core", "scenes", "thunder", "lewd"].every(
                (id) => !!this.sectionHasResult?.[id]
              );
           },

           updateAnalysisComplete(opts = {}) {
             const silent = !!opts.silent;
             const allDone = this.isAllDone();
             if (allDone && !this.analysisComplete && !silent) {
               this.log("success", "分析完成");
               this.showToast("分析完成", "success");
             }
             this.analysisComplete = allDone;
           },

           isTabEnabled(tab) {
             if (!tab) return false;
             if (tab.alwaysEnabled) return true;
             const id = tab.id;
             if (id === "summary") {
               return !!this.sectionHasResult.meta || !!this.sectionHasResult.core;
             }
             if (id === "characters" || id === "relationships") {
               return !!this.sectionHasResult.core;
             }
             if (id === "firstsex" || id === "count" || id === "progress") {
               return !!this.sectionHasResult.scenes;
             }
              if (id === "thunderzones") {
                return !!this.sectionHasResult.thunder;
              }
              if (id === "lewd-elements") {
                return !!this.sectionHasResult.lewd;
              }
              return false;
           },

           isStepActionVisible(stepId) {
              return ["meta", "core", "scenes", "thunder", "lewd"].includes(stepId);
            },

           stepActionLabel(step) {
             const status = step?.status || "idle";
             if (status === "error") return "重试";
             if (status === "done") return "重跑";
             return "运行";
           },

           canRunStep(stepId) {
             if (!this.currentNovelContent) return false;
             if (stepId === "meta" || stepId === "core") return true;
             if (stepId === "scenes" || stepId === "thunder" || stepId === "lewd") {
                return (
                  !!this.sectionHasResult.core &&
                  this.getStepStatus("core") !== "running"
                );
              }
             return false;
           },

           runSingleStep(stepId) {
              if (stepId === "meta") return this.runMeta();
              if (stepId === "core") return this.runCore({ autoRunDependents: false });
              if (stepId === "scenes") return this.runScenes();
              if (stepId === "thunder") return this.runThunder();
              if (stepId === "lewd") return this.runLewdElements();
            },

            invalidateDependentResults(reason = "角色已更新，需要重新分析") {
              if (!this.currentAnalysis) {
                this.currentAnalysis = this.blankAnalysis();
              }
              this.currentAnalysis.first_sex_scenes = [];
              this.currentAnalysis.sex_scenes = { total_count: 0, scenes: [] };
              this.currentAnalysis.evolution = [];
              this.currentAnalysis.thunderzones = [];
              this.currentAnalysis.thunderzone_summary = "";
              this.currentAnalysis.lewd_elements = [];
              this.currentAnalysis.lewd_elements_summary = "";

              this.sectionHasResult.scenes = false;
              this.sectionHasResult.thunder = false;
              this.sectionHasResult.lewd = false;
              this.setProgress("scenes", "pending", reason);
              this.setProgress("thunder", "pending", reason);
              this.setProgress("lewd", "pending", reason);
              this.updateAnalysisComplete();
              this.renderAllData(this.currentAnalysis);
              this.saveAnalysisToStorage(this.currentAnalysis);

              if ([
                "firstsex",
                "count",
                "progress",
                "thunderzones",
                "lewd-elements",
              ].includes(this.currentTab)) {
                this.currentTab = "pipeline";
              }
            },

          initProgressSteps() {
            this.progressSteps = [
             {
               id: "select",
               label: "选择小说",
               status: "idle",
               detail: "等待选择小说",
             },
             {
               id: "load",
               label: "读取小说",
               status: "idle",
               detail: "等待读取",
             },
             {
               id: "meta",
               label: "基础信息 / 总结",
               status: "idle",
               detail: "等待分析",
             },
             {
               id: "core",
               label: "角色 / 关系 / 淫荡指数",
               status: "idle",
               detail: "等待分析",
             },
             {
               id: "scenes",
               label: "首次 / 统计 / 发展",
               status: "idle",
               detail: "等待分析",
             },
             {
               id: "thunder",
               label: "雷点检测",
               status: "idle",
               detail: "等待分析",
             },
             {
               id: "lewd",
               label: "涩情元素",
               status: "idle",
               detail: "等待分析",
             },
            ];
            this.refreshProgressIcons();
          },

          refreshProgressIcons() {
            if (typeof lucide !== "undefined") {
              lucide.createIcons();
            }
          },

          statusLabel(status) {
            const map = {
              idle: "未开始",
              pending: "等待中",
              running: "进行中",
              done: "已完成",
              error: "失败",
            };
            return map[status] || status;
          },

          statusIcon(status) {
            const map = {
              idle: "circle",
              pending: "clock",
              running: "loader-2",
              done: "check-circle-2",
              error: "x-circle",
            };
            return map[status] || "circle";
          },

          setProgress(id, status, detail) {
            const step = this.progressSteps.find((s) => s.id === id);
            if (!step) return;
            step.status = status;
            if (detail !== undefined) {
              step.detail = detail;
            }
            this.refreshProgressIcons();
          },

          resetProgress() {
            this.initProgressSteps();
          },

           markProgressRestored() {
             this.initProgressSteps();
             this.setProgress("select", "done", "已恢复选择");
             this.setProgress("load", "done", "已恢复内容");
             this.setProgress("meta", "done", "已恢复");
             this.setProgress("core", "done", "已恢复");
              this.setProgress("scenes", "done", "已恢复");
              this.setProgress("thunder", "done", "已恢复");
              this.setProgress("lewd", "done", "已恢复");
              this.sectionHasResult = {
                meta: true,
                core: true,
                scenes: true,
                thunder: true,
                lewd: true,
              };
           },

          log(level, message, data = null) {
            const now = new Date();
            const time =
              now.toLocaleTimeString() +
              "." +
              String(now.getMilliseconds()).padStart(3, "0");
            const entry = {
              level,
              time,
              message: String(message ?? ""),
              data:
                data !== null && data !== undefined
                  ? typeof data === "string"
                    ? data
                    : JSON.stringify(data, null, 2)
                  : null,
            };
            this.logs.push(entry);
            console.log(`[${level}] ${message}`, data);
          },

          clearLog() {
            this.logs = [];
          },

          showToast(msg, type = "info") {
            const container = document.getElementById("toastContainer");
            const colors = {
              success: "bg-success text-success-content",
              error: "bg-error text-error-content",
              info: "bg-base-200",
              warning: "bg-warning text-warning-content",
            };
            const toast = document.createElement("div");
            toast.className = `px-5 py-3 rounded-full shadow-lg ${
              colors[type] || "bg-base-200"
            } transition-opacity`;
            const span = document.createElement("span");
            span.className = "text-sm";
            span.textContent = String(msg ?? "");
            toast.appendChild(span);
            container.appendChild(toast);
            setTimeout(() => {
              toast.style.opacity = "0";
              setTimeout(() => toast.remove(), 300);
            }, 3000);
          },

          async testConnection() {
            this.testLoading = true;
            this.testResult = "";
            this.log("info", `测试连接`);
            try {
              const res = await fetch("/api/test-connection", {
                cache: "no-store",
              });
              const data = await res.json();
              if (res.ok) {
                this.testResult = "success";
                this.testResultMsg = "连接成功";
                this.log("success", "连接成功");
              } else {
                this.testResult = "error";
                this.testResultMsg = data.detail || "连接失败";
                this.log("error", "连接失败", data.detail);
              }
            } catch (e) {
              this.testResult = "error";
              this.testResultMsg = e.message;
              this.log("error", "连接异常", e.message);
            }
            this.testLoading = false;
          },

          async scanNovels() {
            this.log("info", "扫描小说目录...");
            try {
              const res = await fetch("/api/novels");
              const data = await res.json();
              this.fileStats = `${data.total} 本小说`;
              this.log("success", `扫描完成，找到 ${data.total} 本小说`);
              this.renderFolderList(data.novels);
            } catch (e) {
              this.fileStats = "扫描失败";
              this.log("error", "扫描失败", e.message);
            }
          },

          renderFolderList(novels) {
            const container = document.getElementById("folderList2");
            if (!container) return;
            container.replaceChildren();

            const frag = document.createDocumentFragment();
            (novels || []).forEach((folder) => {
              const folderDiv = document.createElement("div");
              folderDiv.className = "mb-2";

              const folderLabel = document.createElement("div");
              folderLabel.className = "text-xs opacity-40 px-3 py-1";
              folderLabel.textContent = folder.folder || "";
              folderDiv.appendChild(folderLabel);

              (folder.files || []).forEach((file) => {
                const item = document.createElement("div");
                item.className =
                  "px-3 py-2.5 rounded-lg cursor-pointer hover:bg-[var(--glass)] text-sm truncate file-item transition-colors";
                item.dataset.path = String(file.path ?? "");
                item.dataset.name = String(file.name ?? "");
                item.textContent = String(file.name ?? "");
                item.addEventListener("click", () => {
                  this.selectNovel(item.dataset.path, item.dataset.name, item);
                  document.activeElement?.blur();
                });
                folderDiv.appendChild(item);
              });

              frag.appendChild(folderDiv);
            });
            container.appendChild(frag);
          },

           async selectNovel(path, name, element) {
             document
               .querySelectorAll(".file-item")
               .forEach((el) => el.classList.remove("bg-primary/20"));
             element.classList.add("bg-primary/20");
             this.selectedNovel = { path, name };
             this.novelTitle = name;
             this.analysisComplete = false;
             this.currentAnalysis = null;
             this.coreRevision = 0;
             this.sectionRunId = { meta: 0, core: 0, scenes: 0, thunder: 0, lewd: 0 };
             this.sectionHasResult = {
               meta: false,
               core: false,
               scenes: false,
               thunder: false,
               lewd: false,
             };
             this.activeRequests = 0;
             this.loading = false;
             this.currentNovelContent = null;
             this.currentNovelLength = 0;
             localStorage.removeItem("novel_analyzer_data");
             this.clearRenderedResults();
             this.resetProgress();
             this.currentTab = "pipeline";
             this.errorMsg = "";
             this.log("info", `选择小说: ${name}`);
             this.setProgress("select", "done", `已选择：${name}`);
             this.setProgress("load", "running", "读取小说中...");


            try {
              const res = await fetch(`/api/novel/${encodeURIComponent(path)}`);
              const data = await res.json();
              this.currentNovelContent = data.content;
              this.currentNovelLength = data.length;
              this.setProgress(
                "load",
                "done",
                `字数：${this.formatWordCount(data.length)}字`
              );
              this.log("success", `小说加载成功，字数: ${data.length}`);
            } catch (e) {
              this.errorMsg = "读取小说失败: " + e.message;
              this.currentNovelContent = null;
              this.currentNovelLength = 0;
              this.setProgress("load", "error", "读取失败");
              this.log("error", "读取失败", e.message);
            }
          },

           async postJson(url, payload) {
             const res = await fetch(url, {
               method: "POST",
               headers: { "Content-Type": "application/json" },
               body: JSON.stringify(payload),
             });
             const data = await res.json();
             if (!res.ok) {
               throw new Error(data.detail || "分析失败");
             }
             return data;
           },

           ensureAnalysisObject() {
             if (!this.currentAnalysis) {
               this.currentAnalysis = this.blankAnalysis();
             }
           },

           applyAnalysisPatch(patch) {
             this.ensureAnalysisObject();
             Object.assign(this.currentAnalysis, patch || {});
             this.renderAllData(this.currentAnalysis);
             this.saveAnalysisToStorage(this.currentAnalysis);
           },

           async runMeta() {
             if (!this.currentNovelContent) return;
             if (this.getStepStatus("meta") === "running") return;

             const hadResult = !!this.sectionHasResult.meta;
             const runId = (this.sectionRunId.meta = (this.sectionRunId.meta || 0) + 1);

             this.setProgress("meta", "running", "请求中...");
             this.updateAnalysisComplete();
             this.beginRequest();
             try {
               const metaRes = await this.postJson("/api/analyze/meta", {
                 content: this.currentNovelContent,
               }).then((data) => data.analysis);

               if (runId !== this.sectionRunId.meta) return;

               const novelInfo = metaRes?.novel_info ? { ...metaRes.novel_info } : {};
               const detectedChapters = this.detectChapterCount(this.currentNovelContent);
               const chapterCountNum = Number(novelInfo.chapter_count);
               if (
                 detectedChapters > 0 &&
                 (!Number.isFinite(chapterCountNum) || chapterCountNum <= 0)
               ) {
                 novelInfo.chapter_count = detectedChapters;
               }

               this.setProgress("meta", "done", "已完成");
               this.sectionHasResult.meta = true;
               this.applyAnalysisPatch({
                 novel_info: novelInfo,
                 summary: metaRes?.summary || "",
               });
             } catch (e) {
               if (runId !== this.sectionRunId.meta) return;
               const msg = e.message || "失败";
               if (hadResult) {
                 this.setProgress("meta", "done", `重跑失败: ${msg}（保留上次结果）`);
               } else {
                 this.setProgress("meta", "error", msg);
                 this.sectionHasResult.meta = false;
               }
               this.log("error", "Meta 失败", e.message || String(e));
             } finally {
               this.endRequest();
               this.updateAnalysisComplete();
             }
           },

           async runCore({ autoRunDependents } = { autoRunDependents: false }) {
             if (!this.currentNovelContent) return;
             if (this.getStepStatus("core") === "running") return;

             const hadResult = !!this.sectionHasResult.core;
             const runId = (this.sectionRunId.core = (this.sectionRunId.core || 0) + 1);

             this.setProgress("core", "running", "请求中...");
             this.updateAnalysisComplete();
             this.beginRequest();
             try {
               const coreRes = await this.postJson("/api/analyze/core", {
                 content: this.currentNovelContent,
               }).then((data) => data.analysis);

               if (runId !== this.sectionRunId.core) return;

               this.ensureAnalysisObject();
               this.currentAnalysis.characters = coreRes?.characters || [];
               this.currentAnalysis.relationships = coreRes?.relationships || [];
               this.coreRevision += 1;

               this.setProgress("core", "done", "已完成");
               this.sectionHasResult.core = true;
               this.invalidateDependentResults(
                 autoRunDependents ? "准备分析..." : "角色已更新，需要重新分析"
               );

                if (autoRunDependents) {
                  this.runScenes();
                  this.runThunder();
                  this.runLewdElements();
                }
             } catch (e) {
               if (runId !== this.sectionRunId.core) return;
               const msg = e.message || "失败";
               if (hadResult) {
                 this.setProgress("core", "done", `重跑失败: ${msg}（保留上次结果）`);
               } else {
                 this.setProgress("core", "error", msg);
                 this.sectionHasResult.core = false;
               }
               this.log("error", "Core 失败", e.message || String(e));
             } finally {
               this.endRequest();
               this.updateAnalysisComplete();
             }
           },

           async runScenes() {
             if (!this.currentNovelContent) return;
             if (!this.sectionHasResult.core || this.getStepStatus("core") === "running") {
               this.setProgress("scenes", "pending", "等待角色结果");
               return;
             }
             if (this.getStepStatus("scenes") === "running") return;

             const hadResult = !!this.sectionHasResult.scenes;
             const runId = (this.sectionRunId.scenes = (this.sectionRunId.scenes || 0) + 1);
             const coreRevision = this.coreRevision;

             this.setProgress("scenes", "running", "请求中...");
             this.updateAnalysisComplete();
             this.beginRequest();
             try {
               const scenesRes = await this.postJson("/api/analyze/scenes", {
                 content: this.currentNovelContent,
                 characters: this.currentAnalysis?.characters || [],
                 relationships: this.currentAnalysis?.relationships || [],
               }).then((data) => data.analysis);

               if (runId !== this.sectionRunId.scenes) return;
               if (coreRevision !== this.coreRevision) {
                 this.setProgress("scenes", "pending", "角色已更新，请重跑");
                 return;
               }

               this.setProgress("scenes", "done", "已完成");
               this.sectionHasResult.scenes = true;
               this.applyAnalysisPatch({
                 first_sex_scenes: scenesRes?.first_sex_scenes || [],
                 sex_scenes: scenesRes?.sex_scenes || { total_count: 0, scenes: [] },
                 evolution: scenesRes?.evolution || [],
               });
             } catch (e) {
               if (runId !== this.sectionRunId.scenes) return;
               const msg = e.message || "失败";
               if (hadResult) {
                 this.setProgress("scenes", "done", `重跑失败: ${msg}（保留上次结果）`);
               } else {
                 this.setProgress("scenes", "error", msg);
                 this.sectionHasResult.scenes = false;
               }
               this.log("error", "Scenes 失败", e.message || String(e));
             } finally {
               this.endRequest();
               this.updateAnalysisComplete();
             }
           },



            async runLewdElements() {
              if (!this.currentNovelContent) return;
              if (!this.sectionHasResult.core || this.getStepStatus("core") === "running") {
                this.setProgress("lewd", "pending", "等待角色结果");
                return;
              }
              if (this.getStepStatus("lewd") === "running") return;

              const hadResult = !!this.sectionHasResult.lewd;
              const runId = (this.sectionRunId.lewd = (this.sectionRunId.lewd || 0) + 1);
              const coreRevision = this.coreRevision;

              this.setProgress("lewd", "running", "请求中...");
              this.updateAnalysisComplete();
              this.beginRequest();
              try {
                const lewdRes = await this.postJson("/api/analyze/lewd-elements", {
                  content: this.currentNovelContent,
                  characters: this.currentAnalysis?.characters || [],
                  relationships: this.currentAnalysis?.relationships || [],
                }).then((data) => data.analysis);

                if (runId !== this.sectionRunId.lewd) return;
                if (coreRevision !== this.coreRevision) {
                  this.setProgress("lewd", "pending", "角色已更新，请重跑");
                  return;
                }

                this.setProgress("lewd", "done", "已完成");
                this.sectionHasResult.lewd = true;
                this.applyAnalysisPatch({
                  lewd_elements: lewdRes?.lewd_elements || [],
                  lewd_elements_summary: lewdRes?.lewd_elements_summary || "",
                });
              } catch (e) {
                if (runId !== this.sectionRunId.lewd) return;
                const msg = e.message || "失败";
                if (hadResult) {
                  this.setProgress("lewd", "done", `重跑失败: ${msg}（保留上次结果）`);
                } else {
                  this.setProgress("lewd", "error", msg);
                  this.sectionHasResult.lewd = false;
                }
                this.log("error", "LewdElements 失败", e.message || String(e));
              } finally {
                this.endRequest();
                this.updateAnalysisComplete();
              }
            },

            async runThunder() {
              if (!this.currentNovelContent) return;
              if (!this.sectionHasResult.core || this.getStepStatus("core") === "running") {
               this.setProgress("thunder", "pending", "等待角色结果");
               return;
             }
             if (this.getStepStatus("thunder") === "running") return;

             const hadResult = !!this.sectionHasResult.thunder;
             const runId = (this.sectionRunId.thunder = (this.sectionRunId.thunder || 0) + 1);
             const coreRevision = this.coreRevision;

             this.setProgress("thunder", "running", "请求中...");
             this.updateAnalysisComplete();
             this.beginRequest();
             try {
               const thunderRes = await this.postJson("/api/analyze/thunderzones", {
                 content: this.currentNovelContent,
                 characters: this.currentAnalysis?.characters || [],
                 relationships: this.currentAnalysis?.relationships || [],
               }).then((data) => data.analysis);

               if (runId !== this.sectionRunId.thunder) return;
               if (coreRevision !== this.coreRevision) {
                 this.setProgress("thunder", "pending", "角色已更新，请重跑");
                 return;
               }

               this.setProgress("thunder", "done", "已完成");
               this.sectionHasResult.thunder = true;
               this.applyAnalysisPatch({
                 thunderzones: thunderRes?.thunderzones || [],
                 thunderzone_summary: thunderRes?.thunderzone_summary || "",
               });
             } catch (e) {
               if (runId !== this.sectionRunId.thunder) return;
               const msg = e.message || "失败";
               if (hadResult) {
                 this.setProgress("thunder", "done", `重跑失败: ${msg}（保留上次结果）`);
               } else {
                 this.setProgress("thunder", "error", msg);
                 this.sectionHasResult.thunder = false;
               }
               this.log("error", "Thunder 失败", e.message || String(e));
             } finally {
               this.endRequest();
               this.updateAnalysisComplete();
             }
           },

           async loadLlmDumps() {
              this.llmDumpsLoading = true;
              try {
                const res = await fetch("/api/debug/llm-dumps?limit=200", {
                 cache: "no-store",
               });
               const data = await res.json();
               if (!res.ok) {
                 throw new Error(data.detail || "加载 dumps 失败");
               }
               this.llmDumps = Array.isArray(data.items) ? data.items : [];
             } catch (e) {
               this.log("error", "加载 dumps 失败", e.message || String(e));
             }
             this.llmDumpsLoading = false;
           },

           async loadLlmDump(id) {
             this.selectedDumpId = id || "";
             this.selectedDumpText = "";
             if (!id) return;
             try {
               const res = await fetch(
                 "/api/debug/llm-dumps/" + encodeURIComponent(id),
                 { cache: "no-store" }
               );
               const data = await res.json();
               if (!res.ok) {
                 throw new Error(data.detail || "读取 dump 失败");
               }
               this.selectedDumpText = JSON.stringify(data.dump || data, null, 2);
             } catch (e) {
               this.selectedDumpText = `读取失败: ${e.message || String(e)}`;
               this.log("error", "读取 dump 失败", e.message || String(e));
             }
           },

           async clearLlmDumps() {
             this.llmDumpsLoading = true;
             try {
               const res = await fetch("/api/debug/llm-dumps", {
                 method: "DELETE",
               });
               const data = await res.json();
               if (!res.ok) {
                 throw new Error(data.detail || "清空失败");
               }
               this.llmDumps = [];
               this.selectedDumpId = "";
               this.selectedDumpText = "";
               this.showToast(`已清空 ${data.deleted || 0} 条 dumps`, "success");
             } catch (e) {
               this.log("error", "清空 dumps 失败", e.message || String(e));
             }
             this.llmDumpsLoading = false;
           },

           analysisJson() {
             try {
               return JSON.stringify(this.currentAnalysis || null, null, 2);
             } catch {
               return "";
             }
           },

           async copyText(text) {
             const value = String(text ?? "");
             if (!value) return;
             try {
               await navigator.clipboard.writeText(value);
               this.showToast("已复制", "success");
             } catch (e) {
               this.log("error", "复制失败", e.message || String(e));
             }
           },

            async analyzeNovel() {
              if (!this.selectedNovel || !this.currentNovelContent) {
                this.errorMsg = "请先选择一本小说";
                return;
              }

              this.errorMsg = "";
              this.log("info", `开始分析: ${this.selectedNovel.name}`);
              this.analysisComplete = false;
              this.currentTab = "pipeline";
              this.currentAnalysis = this.blankAnalysis();
              this.coreRevision = 0;
              this.sectionRunId = { meta: 0, core: 0, scenes: 0, thunder: 0, lewd: 0 };
              this.sectionHasResult = {
                meta: false,
                core: false,
                scenes: false,
                thunder: false,
                lewd: false,
              };
              localStorage.removeItem("novel_analyzer_data");
              this.clearRenderedResults();
              this.renderAllData(this.currentAnalysis);

              this.setProgress("meta", "idle", "等待分析");
              this.setProgress("core", "idle", "等待分析");
              this.setProgress("scenes", "pending", "等待角色结果");
              this.setProgress("thunder", "pending", "等待角色结果");
              this.setProgress("lewd", "pending", "等待角色结果");
              this.updateAnalysisComplete();

              this.runMeta();
              this.runCore({ autoRunDependents: true });
            },

          renderAllData(data) {
            const chars = data.characters || [];
            const wordCount = this.currentNovelContent
              ? this.currentNovelContent.length
              : 0;

            const toInt = (value, fallback = 0) => {
              const n = Number(value);
              return Number.isFinite(n) ? Math.trunc(n) : fallback;
            };

            const sexCount = toInt(data.sex_scenes?.total_count, 0);
            const relationshipCount = Array.isArray(data.relationships)
              ? data.relationships.length
              : 0;
            const characterCount = chars.length;
            const wordCountText = this.formatWordCount(wordCount);

            const quickStats = document.getElementById("quickStats");
            renderQuickStats(quickStats, {
              sexCount,
              relationshipCount,
              characterCount,
              wordCountText,
              novelInfo: data.novel_info,
            });

            renderRelationshipSummary(data);
            renderCharacters(data);
            renderFirstSexScene(data);
            renderSexSceneCount(data);
            renderRelationshipProgress(data);
            renderRelationshipDetails(data);
            renderThunderzones(document.getElementById("thunderzoneSection"), {
              analysis: data,
            });
            renderLewdElements(document.getElementById("lewdElementsSection"), {
              analysis: data,
            });
            if (this.currentTab === "relationships") {
              requestAnimationFrame(() => {
                requestAnimationFrame(() =>
                  renderRelationshipGraph("relationshipChart", data)
                );
              });
            }
          },

          saveAnalysisToStorage(analysis) {
            try {
              localStorage.setItem(
                "novel_analyzer_data",
                JSON.stringify({
                  analysis,
                  novel: this.selectedNovel,
                  sectionHasResult: this.sectionHasResult,
                  progress: (this.progressSteps || []).map((s) => ({
                    id: s.id,
                    status: s.status,
                    detail: s.detail,
                  })),
                  timestamp: Date.now(),
                })
              );
            } catch (e) {
              this.log("error", "保存失败", e.message);
            }
          },

          restoreAnalysis() {
            try {
              const saved = localStorage.getItem("novel_analyzer_data");
              if (!saved) return;
              const data = JSON.parse(saved);
              if (!data.analysis || !data.novel) return;

              this.currentAnalysis = data.analysis;
              this.selectedNovel = data.novel;
              this.novelTitle = data.novel.name;
              this.coreRevision = 0;
              this.sectionRunId = { meta: 0, core: 0, scenes: 0, thunder: 0, lewd: 0 };
              this.sectionHasResult = { meta: false, core: false, scenes: false, thunder: false, lewd: false };

              const progress = Array.isArray(data.progress) ? data.progress : null;
              this.initProgressSteps();
              this.setProgress("select", "done", "已恢复选择");
              this.setProgress("load", "done", "已恢复内容");
               if (progress) {
                 for (const item of progress) {
                   if (!item || !item.id) continue;
                   this.setProgress(item.id, item.status, item.detail);
                 }
                 if (data.sectionHasResult && typeof data.sectionHasResult === "object") {
                   this.sectionHasResult = {
                     meta: !!data.sectionHasResult.meta,
                     core: !!data.sectionHasResult.core,
                     scenes: !!data.sectionHasResult.scenes,
                     thunder: !!data.sectionHasResult.thunder,
                     lewd: !!data.sectionHasResult.lewd,
                   };
                 } else {
                   this.sectionHasResult = {
                     meta: this.getStepStatus("meta") === "done",
                     core: this.getStepStatus("core") === "done",
                     scenes: this.getStepStatus("scenes") === "done",
                     thunder: this.getStepStatus("thunder") === "done",
                     lewd: this.getStepStatus("lewd") === "done",
                   };
                 }
               } else {
                 if (data.sectionHasResult && typeof data.sectionHasResult === "object") {
                   this.sectionHasResult = {
                     meta: !!data.sectionHasResult.meta,
                     core: !!data.sectionHasResult.core,
                     scenes: !!data.sectionHasResult.scenes,
                     thunder: !!data.sectionHasResult.thunder,
                     lewd: !!data.sectionHasResult.lewd,
                   };
                   this.setProgress(
                     "meta",
                     this.sectionHasResult.meta ? "done" : "idle",
                     this.sectionHasResult.meta ? "已恢复" : "等待分析"
                   );
                   this.setProgress(
                     "core",
                     this.sectionHasResult.core ? "done" : "idle",
                     this.sectionHasResult.core ? "已恢复" : "等待分析"
                   );
                   this.setProgress(
                     "scenes",
                     this.sectionHasResult.scenes ? "done" : "pending",
                     this.sectionHasResult.scenes ? "已恢复" : "等待分析"
                   );
                   this.setProgress(
                     "thunder",
                     this.sectionHasResult.thunder ? "done" : "pending",
                     this.sectionHasResult.thunder ? "已恢复" : "等待分析"
                   );
                   this.setProgress(
                     "lewd",
                     this.sectionHasResult.lewd ? "done" : "pending",
                     this.sectionHasResult.lewd ? "已恢复" : "等待分析"
                   );
                 } else {
                   this.markProgressRestored();
                 }
               }

              this.updateAnalysisComplete({ silent: true });
              this.renderAllData(data.analysis);
              this.currentTab = "summary";
              this.showToast("已恢复上次分析结果", "info");
              this.log("info", "已恢复上次分析结果");
            } catch (e) {
              this.log("error", "恢复失败", e.message);
            }
          },

           clearAnalysis() {
              localStorage.removeItem("novel_analyzer_data");
              this.currentAnalysis = null;
              this.coreRevision = 0;
              this.sectionRunId = { meta: 0, core: 0, scenes: 0, thunder: 0, lewd: 0 };
              this.sectionHasResult = { meta: false, core: false, scenes: false, thunder: false, lewd: false };
              this.activeRequests = 0;
              this.loading = false;
              this.selectedNovel = null;
              this.novelTitle = "选择一本小说";
              this.analysisComplete = false;
              this.currentNovelContent = null;
              this.currentNovelLength = 0;
             this.currentTab = "pipeline";
             this.resetProgress();
             document
               .querySelectorAll(".file-item")
               .forEach((el) => el.classList.remove("bg-primary/20"));
             this.clearRenderedResults();
             this.showToast("已清空分析结果", "info");
             this.settingsOpen = false;
             this.log("info", "已清空所有数据");
           },

          clearRenderedResults() {
            [
              "quickStats",
              "relationshipSummary",
              "thunderzoneSection",
              "lewdElementsSection",
              "mainCharacters",
              "firstSexScene",
              "sexSceneCount",
              "relationshipProgress",
              "relationshipDetails",
            ].forEach((id) => {
              const el = document.getElementById(id);
              if (el) el.replaceChildren();
            });
            const chart = document.getElementById("relationshipChart");
            if (chart) chart.replaceChildren();
          },

          doExport() {
            if (!this.currentAnalysis || !this.selectedNovel) {
              this.errorMsg = "没有可导出的数据";
              return;
            }
            exportReport(this.currentAnalysis, this.selectedNovel.name, {
              wordCount: this.currentNovelContent
                ? this.currentNovelContent.length
                : 0,
            });
            this.showToast("报告已导出", "success");
          },
        };
      }
    </script>
  </body>
</html>
